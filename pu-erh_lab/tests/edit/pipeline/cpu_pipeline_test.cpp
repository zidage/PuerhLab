#ifdef _WIN32
#include <opencv2/cudaimgproc.hpp>
#include <string>

#include "decoders/raw_decoder.hpp"
#include "edit/operators/detail/clarity_op.hpp"
#include "edit/operators/op_base.hpp"
#include "edit/operators/operator_factory.hpp"
#include "edit/pipeline/pipeline_cpu.hpp"
#include "image/image_buffer.hpp"
#include "pipeline_test_fixation.hpp"
#include "sleeve/sleeve_manager.hpp"
#include "type/supported_file_type.hpp"
#include "utils/clock/time_provider.hpp"
#include "utils/string/convert.hpp"

using namespace puerhlab;

#include <lcms2.h>

#include <algorithm>
#include <fstream>

// clamp helper
static inline double sat(double v) { return std::min(1.0, std::max(0.0, v)); }

void                 BakeLUT(std::string src, std::string dest, std::string save) {
  const char*     srcIcc = src.c_str();   // Source ICC
  const char*     dstIcc = dest.c_str();  // Destination ICC
  const int       N      = 33;            // LUT_3D_SIZE

  cmsHPROFILE     in     = cmsOpenProfileFromFile(srcIcc, "r");
  cmsHPROFILE     out    = cmsOpenProfileFromFile(dstIcc, "r");

  cmsUInt32Number fmt    = TYPE_RGB_DBL;
  int             intent = INTENT_RELATIVE_COLORIMETRIC;  // 或 INTENT_PERCEPTUAL 等
  cmsUInt32Number flags = cmsFLAGS_BLACKPOINTCOMPENSATION | cmsFLAGS_HIGHRESPRECALC;

  cmsHTRANSFORM   xf    = cmsCreateTransform(in, fmt, out, fmt, intent, flags);

  std::ofstream   f(save);
  f << "# Generated by lcms2 sampler\n";
  f << "LUT_3D_SIZE " << N << "\n";
  f << "DOMAIN_MIN 0.0 0.0 0.0\nDOMAIN_MAX 1.0 1.0 1.0\n";

  for (int b = 0; b < N; ++b)
    for (int g = 0; g < N; ++g)
      for (int r = 0; r < N; ++r) {
        double inRGB[3] = {r / double(N - 1), g / double(N - 1), b / double(N - 1)};
        double outRGB[3];
        cmsDoTransform(xf, inRGB, outRGB, 1);
        f << sat(outRGB[0]) << " " << sat(outRGB[1]) << " " << sat(outRGB[2]) << "\n";
      }

  cmsDeleteTransform(xf);
  cmsCloseProfile(in);
  cmsCloseProfile(out);
}

TEST_F(PipelineTests, SimpleTest1) {
  {
    // BakeLUT("D:\\misc\\toushi\\Profiles\\sRGB.icc",
    //         "D:\\misc\\toushi\\Profiles\\Hasselblad Rec709.icc");

    SleeveManager manager{db_path_};
    ImageLoader   image_loader(128, 8, 0);
    image_path_t  path = std::string(TEST_IMG_PATH) + "raw/building";
    ;
    std::vector<image_path_t> imgs;
    for (const auto& img : std::filesystem::directory_iterator(path)) {
      if (!img.is_directory() && is_supported_file(img.path())) imgs.push_back(img.path());
    }

    manager.LoadToPath(imgs, L"");

    // Read image data
    ThreadPool     thread_pool{8};
    auto           img_pool = manager.GetPool()->GetPool();

    nlohmann::json to_ws_params;
    to_ws_params["ocio"] = {
        {"src", "Linear Rec.709 (sRGB)"}, {"dst", "ACEScct"}, {"normalize", true}};

    nlohmann::json basic_params;
    // basic_params["ocio"] = {{"src", ""}, {"dst", "ACEScct"}};
    basic_params["exposure"]   = 0.5f;
    basic_params["highlights"] = -55.0f;
    basic_params["shadows"]    = 25.0f;
    basic_params["white"]      = 15.0f;
    basic_params["black"]      = -15.0f;

    nlohmann::json color_params;
    color_params["vibrance"]    = 50.0f;
    color_params["tint"]        = -3.0f;
    color_params["clarity"]     = 95.0f;

    color_params["color_wheel"] = {{"lift",
                                    {{"color_offset.x", 0.0},
                                     {"color_offset.y", 0.0},
                                     {"color_offset.z", 0.0},
                                     {"luminance_offset", 0.0}}},
                                   {"gamma",
                                    {{"color_offset.x", 1.0},
                                     {"color_offset.y", 1.0},
                                     {"color_offset.z", 1.00},
                                     {"luminance_offset", 0.2}}},
                                   {"gain",
                                    {{"color_offset.x", 1.0},
                                     {"color_offset.y", 1.0},
                                     {"color_offset.z", 1.0},
                                     {"luminance_offset", -0.4}}},
                                   {"crossovers", {{"lift", 0.2}, {"gain", 0.8}}}};

    nlohmann::json contrast_params;
    contrast_params["contrast"] = 5.0f;
    nlohmann::json lmt_params;
    lmt_params["ocio_lmt"] = CONFIG_PATH "LUTs/ACES CCT 2383 D65.cube";
    // lmt_params["ocio"] = {{"src", "ACEScct"}, {"dst", "Camera Rec.709"}, {"limit", true}};

    nlohmann::json output_params;
    output_params["ocio"] = {{"src", "ACEScct"}, {"dst", "Camera Rec.709"}, {"limit", true}};

    for (auto& pair : img_pool) {
      auto task = [pair, img_pool, to_ws_params, basic_params, color_params, lmt_params,
                   output_params]() mutable {
        CPUPipelineExecutor pipeline{};
        auto&               to_ws = pipeline.GetStage(PipelineStageName::To_WorkingSpace);
        // to_ws.SetOperator(OperatorType::EXPOSURE, basic_params);
        to_ws.SetOperator(OperatorType::CST, to_ws_params);

        auto& adj          = pipeline.GetStage(PipelineStageName::Basic_Adjustment);
        // adj.SetOperator(OperatorType::EXPOSURE, basic_params);
        // adj.SetOperator(OperatorType::SHADOWS, basic_params);
        // adj.SetOperator(OperatorType::WHITE, basic_params);
        // adj.SetOperator(OperatorType::BLACK, basic_params);

        auto& color_adj    = pipeline.GetStage(PipelineStageName::Color_Adjustment);
        // color_adj.SetOperator(OperatorType::CST, to_ws_params);
        // color_adj.SetOperator(OperatorType::TINT, color_params);
        // color_adj.SetOperator(OperatorType::CLARITY, color_params);

        auto& lmt          = pipeline.GetStage(PipelineStageName::Color_Adjustment);
        // lmt.SetOperator(OperatorType::LMT, lmt_params);
        //

        auto& output_stage = pipeline.GetStage(PipelineStageName::Output_Transform);
        output_stage.SetOperator(OperatorType::CST, output_params);
        // output_stage.SetOperator(OperatorType::ACES_TONE_MAPPING, output_params);
        // output_stage.SetOperator(OperatorType::LMT, lmt_params);

        auto            img = pair.second;
        RawDecoder      decoder;
        std::ifstream   file(img->_image_path, std::ios::binary | std::ios::ate);
        std::streamsize fileSize = file.tellg();
        file.seekg(0, std::ios::beg);
        std::vector<char> buffer(fileSize);
        if (!file.read(buffer.data(), fileSize)) {
          FAIL();
        }
        file.close();
        decoder.Decode(std::move(buffer), img);

        auto source = std::make_shared<ImageBuffer>(img->GetImageData());
        auto output = pipeline.Apply(source);

        cv::cuda::GpuMat to_save_rec709;
        cv::Mat          to_save_rec709_cpu;

        output->SyncToGPU();

        auto& gpu_data = output->GetGPUData();
        gpu_data.convertTo(to_save_rec709, CV_16UC3, 65535.0f);
        cv::cuda::cvtColor(to_save_rec709, to_save_rec709, cv::COLOR_RGB2BGR);
        to_save_rec709.download(to_save_rec709_cpu);

        std::string           file_name = conv::ToBytes(img->_image_path.filename().wstring());
        std::string           time      = TimeProvider::TimePointToString(TimeProvider::Now());

        std::string           save_name = file_name + "_" + time;
        static constexpr auto save_path = TEST_IMG_PATH "/my_pipeline/batch_results/{}.tif";
        cv::imwrite(std::format(save_path, save_name), to_save_rec709_cpu);

        img->ClearData();
        to_save_rec709.release();
        output->ReleaseCPUData();
        output->ReleaseGPUData();
        to_save_rec709_cpu.release();
      };
      thread_pool.Submit(task);
    }
  }
}
#endif